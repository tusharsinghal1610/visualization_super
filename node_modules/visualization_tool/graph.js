let getPackageInfo = require('./getPackageInfo');
var fs = require('fs');
module.exports = class Graph {
     constructor(){
         this.nodeInfo = new Map();
         this.edges = [];
         this.nodeId = new Map();
         this.count = 1;
     }
     addEdge(u,v){
         this.nodeInfo.get(v).parent.push(u);
         this.edges.push({from: this.nodeId.get(u),to:this.nodeId.get(v)});
     }
     versionDependencyMaker(dependencies){
        let versionedDependencies = [];
        for(let key in dependencies){
            let value = dependencies[key];
            value = value.split('|')[value.split('|').length-1].trim();
            if(value[0] == '^' || value[0] == '~')
            {
                value = value.slice(1,value.length);
            }
            while(value.split('.').length < 3){
                value = value + '.0';
            }
            value = key + '@' + value
            versionedDependencies.push(value);
        }
        return versionedDependencies;
     }
     async buildGraphUtil(parentPackage){
         return new Promise(async (resolve,reject)=>{
            if(parentPackage.dependencies){
                let totalDependencies = Object.keys(parentPackage.dependencies).length;
                if(totalDependencies == 0){
                    resolve();
                }
                else{
                    let dependencies = this.versionDependencyMaker(parentPackage.dependencies)   
                    let i=0;
                    while(i<totalDependencies){
                  
                        let dependency = dependencies[i];
                    
                        if(this.nodeInfo.get(dependency) == undefined){
                            
                            let data = await getPackageInfo(dependency);
                            data.parent = [];
                            this.nodeInfo.set(dependency,data);
                            this.nodeId.set(data._id,this.count);
                            this.count++;
                         
                            this.addEdge(parentPackage._id,data._id);
                            await this.buildGraphUtil(data); 
                            i++;
                            if(i == (totalDependencies)){

                                resolve();
                            }
                        }
                        else{
                          
                            this.addEdge(parentPackage._id,dependency);
                            i++;
                            if(i == (totalDependencies)){
                                resolve();
                            }
                        }
                    } 
                }
            }
            else{
                resolve();
            }
         }); 
     }
     async buildGraph(rootPackages){
         return new Promise((resolve,reject)=>{
            console.log('\x1b[32m%s',"\n\n       WAIT , BUILDING THE GRAPH .... \n\n ") 
            console.log("\x1b[0m","processing....")
            this.rootPackages = rootPackages; 
            let noOfRootPackages = rootPackages.length;
            rootPackages.map(async (rootPackage,index)=>{
                if(this.nodeInfo.get(rootPackage) == undefined){
              
                    let data = await getPackageInfo(rootPackage);
      
                    data.parent = [];
                    this.nodeInfo.set(data._id,data);
                    this.nodeId.set(data._id,this.count);
                    this.count++;
                    await this.buildGraphUtil(data);
                    if(index == noOfRootPackages-1){
                        console.log("resolved");
                        resolve();
                    }
                }
            });
         });
    }
    showGraph(packages=this.rootPackages,indent=1){
        packages.map((item)=>{
            console.log("        ".repeat(indent),this.nodeInfo.get(item)._id);
            if(this.nodeInfo.get(item).dependencies){
                this.showGraph(Object.keys(this.nodeInfo.get(item).dependencies), indent+1);
            }
        });
    }
    getDependents(packageName){
        this.dependents = [];
        this.getDependentsUtil(packageName);
        return this.dependents;
    }
    getDependentsUtil(packageName,indent=1){
        this.nodeInfo.get(packageName).parent.map((item)=>{
            if(!this.dependents.includes(item)){
                this.dependents.push({parent:item , child:packageName});
            }
            this.getDependentsUtil(item,indent+1);
        });
    }
    printDependents(packageName,indent=1){
        console.log("  ".repeat(indent),this.nodeInfo.get(packageName)._id);
        this.nodeInfo.get(packageName).parent.map((item)=>{
            this.printDependents(item,indent+1);
        });
    }
    generateNodesAndEdges(){
        let keys = this.nodeId.keys();
        let nodeArray = [];
        for(var nodeName of keys){
            nodeArray.push({
                id:this.nodeId.get(nodeName),
                label:nodeName
            });
        }
        let myData = {
            nodes : nodeArray,
            edges : this.edges
        }
        myData = JSON.stringify(myData);
        fs.writeFile('data.json', myData, 'utf8', (err)=>{
           if(err){
               console.log("there was an error in writing the data");
               console.log(err);
           }
       });
    }
}

